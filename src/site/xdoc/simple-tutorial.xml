<document>
  <properties>
    <title>Simple Tutorial</title>
    <author>Arne Limburg</author>
  </properties>
  
  <body>
    <section name="Tutorial">
      <p>
        This Tutorial describes the development of a simple contacts application.
        The server-site code can be found in the source distribution in the test folder.
        This tutorial assumes basic knowledge of the Java Persistence API.
        Beside JPA Security it needs hibernate and hsqldb in its classpath.
      </p>
      <section name="Object Model">
        <p>
          We want to write a simple applications where users can store contacts.
          For this we need two objects annotated with JPA Annotations:
          the users and the contacts.
        </p>
        <source>
@Entity
public class User {

    @Id @GeneratedValue(strategy = GenerationType.IDENTITY)
    private int id;
    @Basic
    private String name;
    
    public User() {
    }
    
    public User(String name) {
        setName(name);
    }
    
    public int getId() {
        return id;
    }
    
    public void setId(int id) {
        this.id = id;
    }
    
    public String getName() {
        return name;
    }
    
    public void setName(String name) {
        this.name = name;
    }   
}

@Entity
public class Contact {

    @Id @GeneratedValue(strategy = GenerationType.IDENTITY)
    private int id;
    @ManyToOne
    private User user;
    @Basic
    private String text;
    
    public Contact() {
    }
    
    public Contact(User user, String text) {
        setUser(user);
        setText(text);
    }
    
    public int getId() {
        return id;
    }
    
    public void setId(int id) {
        this.id = id;
    }
    
    public User getUser() {
        return user;
    }
    
    public void setUser(User user) {
        this.user = user;
    }

    public String getText() {
        return text;
    }
    
    public void setText(String text) {
        this.text = text;
    }
}
        </source>
      </section>
      <section name="Persistence Unit">
        <p>
          In order to use JPA with Hibernate, we need a persistence.xml in the META-INF folder of our application.
          We want Hibernate to use hsqldb and create the schema for us, so our persistence.xml looks like this:
        </p>
        <source>
          <![CDATA[
<persistence xmlns="http://java.sun.com/xml/ns/persistence"
             xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
             xsi:schemaLocation="http://java.sun.com/xml/ns/persistence
                                 http://java.sun.com/xml/ns/persistence/persistence_1_0.xsd"
             version="1.0">

  <persistence-unit name="contacts" transaction-type="RESOURCE_LOCAL">

    <provider>org.hibernate.ejb.HibernatePersistence</provider>

    <class>net.sf.jpasecurity.contacts.User</class>
    <class>net.sf.jpasecurity.contacts.Contact</class>

    <properties>
      <property name="hibernate.hbm2ddl.auto" value="create-drop" />
      <property name="hibernate.dialect" value="org.hibernate.dialect.HSQLDialect" />
      <property name="hibernate.connection.driver_class" value="org.hsqldb.jdbcDriver" />
      <property name="hibernate.connection.url" value="jdbc:hsqldb:mem:contacts" />
      <property name="hibernate.connection.username" value="sa" />
      <property name="hibernate.connection.password" value="" />
    </properties>

  </persistence-unit>

</persistence>
          ]]>
        </source>
      </section>
      <section name="Test Data">
        <p>
          Now we can go and create some users and contacts. For this we must create an EntityManagerFactory,
          an EntityManager, start a Transaction and persist the users:
        </p>
        <source>
EntityManagerFactory entityManagerFactory;
EntityManager entityManager;
entityManagerFactory = Persistence.createEntityManagerFactory("contacts");

entityManager = entityManagerFactory.createEntityManager();
entityManager.getTransaction().begin();
entityManager.persist(new User("John"));
entityManager.persist(new User("Mary"));
entityManager.getTransaction().commit();
entityManager.close();
        </source>
        <p>
          Ok, let's retrieve the users from the database to see whether they were really persisted:
        </p>
        <source>
entityManager = entityManagerFactory.createEntityManager();
entityManager.getTransaction().begin();
List&lt;User&gt; users = entityManager.createQuery("SELECT user FROM User user").getResultList();
System.out.println("users.size = " + users.size);
entityManager.getTransaction().commit();
entityManager.close();
        </source>
        <p>
          As we can see, there are really two users in the database. But are this really John and Mary?
          Let's see:
        </p>
        <source>
entityManager = entityManagerFactory.createEntityManager();
entityManager.getTransaction().begin();
User john = (User)entityManager.createQuery("SELECT user FROM User user WHERE user.name = 'John'").getSingleResult();
User mary = (User)entityManager.createQuery("SELECT user FROM User user WHERE user.name = 'Mary'").getSingleResult();
entityManager.getTransaction().commit();
entityManager.close();
        </source>
        <p>
          If the users would not have been found, the calls to getSingleResult() would have thrown a NoResultException.
          So we can be sure our users are there. Now let's create some contact data for them:
        </p>
        <source>
entityManager = entityManagerFactory.createEntityManager();
entityManager.getTransaction().begin();
entityManager.persist(new Contact(john, "john@jpasecurity.sf.net"));
entityManager.persist(new Contact(john, "0 12 34 - 56 789"));
entityManager.persist(new Contact(mary, "mary@jpasecurity.sf.net"));
entityManager.persist(new Contact(mary, "12 34 56 78 90"));
entityManager.getTransaction().commit();
entityManager.close();
        </source>
        <p>
          Let's see if all four contacts are there:
        </p>
        <source>
entityManager = entityManagerFactory.createEntityManager();
entityManager.getTransaction().begin();
List&lt;Contact&gt; contacts = entityManager.createQuery("SELECT contact FROM Contact contact").getResultList();
System.out.println("contacts.size = " + contacts.size());
entityManager.getTransaction().commit();
entityManager.close();
        </source>
        <p>
          As we can see from the output: All contacts are persisted. Now it's time for some security.
        </p>
      </section>
      <section name="Integrating JPA Security">
        <p>
          In order to integrate JPA Security we need three things to be configured:
          <ul>
            <li>a persistence provider</li>
            <li>an authentication provider and</li>
            <li>a rules provider</li>
          </ul>
          The persistence provider is a JPA persistence provider that does the real work for us.
          In our application this will be Hibernate with its org.hibernate.ejb.HibernatePersistence provider.
          The authentication provider is needed to provide information about the currently authenticated user
          to JPA Security. Read more about this in the appropriate {{{{manual.html#authenticationprovider}}chapter}}
          of the reference manual. In our case a net.sf.jpasecurity.security.authentication.StaticAuthenticationProvider suffers.
          A rules provider provides the access rules on which our security depends. We want to define them in a security.xml
          in our META-INF folder, so we use the net.sf.jpasecurity.security.rules.XmlAccessRulesProvider.
          We change the persistence.xml as follows:
        </p>
        <source>
          <![CDATA[
<persistence-unit name="contacts" transaction-type="RESOURCE_LOCAL">

  <provider>net.sf.jpasecurity.persistence.SecurePersistenceProvider</provider>

  <class>net.sf.jpasecurity.contacts.User</class>
  <class>net.sf.jpasecurity.contacts.Contact</class>

  <properties>
    <property name="net.sf.jpasecurity.persistence.provider" value="org.hibernate.ejb.HibernatePersistence"/>
    <property name="net.sf.jpasecurity.security.authentication.provider"
              value="net.sf.jpasecurity.security.authentication.StaticAuthenticationProvider"/>
    <property name="net.sf.jpasecurity.security.rules.provider"
              value="net.sf.jpasecurity.security.rules.XmlAccessRulesProvider"/>
    <property name="hibernate.hbm2ddl.auto" value="create-drop" />
    <property name="hibernate.dialect" value="org.hibernate.dialect.HSQLDialect" />
    <property name="hibernate.connection.driver_class" value="org.hsqldb.jdbcDriver" />
    <property name="hibernate.connection.url" value="jdbc:hsqldb:mem:contacts" />
    <property name="hibernate.connection.username" value="sa" />
    <property name="hibernate.connection.password" value="" />
  </properties>

</persistence-unit>
          ]]>
        </source>
        <p>
          The following line has changed in order to use JPA Security:
        </p>
        <source>
          <provider>net.sf.jpasecurity.persistence.SecurePersistenceProvider</provider>
        </source>
        <p>
          The following lines are added to specify persistence provider, authentication provider and rules provider:
        </p>
        <source>
          <![CDATA[
    <property name="net.sf.jpasecurity.persistence.provider" value="org.hibernate.ejb.HibernatePersistence"/>
    <property name="net.sf.jpasecurity.security.authentication.provider"
              value="net.sf.jpasecurity.security.authentication.AcegiAuthenticationProvider"/>
    <property name="net.sf.jpasecurity.security.rules.provider"
              value="net.sf.jpasecurity.security.rules.XmlAccessRulesProvider"/>
          ]]>
        </source>
        <p>
          OK, let's run our program again and let's see what happens...
        </p>
        <p>
          As you can see from the output of our application: nothing happend, everything stayed as before. JPA Security integrated smooth, we even can't see it work.
          We have not defined access rules for now. We do this by creating a security.xml in the META-INF folder:
        </p>
        <section name="Defining Access Rules">
          <source>
            <![CDATA[
<security>
  <persistence-unit name="contacts">
    <access-rule>GRAND READ ACCESS TO Contact contact WHERE contact.user = :user</access-rule>
    <access-rule>GRAND READ ACCESS TO Contact contact WHERE 'admin' IN (:roles)</access-rule>
    <access-rule>GRAND READ ACCESS TO User user WHERE 'admin' IN (:roles)</access-rule>
  </persistence-unit>
</security>
            ]]>
          </source>
          <p>
  This are three access rules that show the capability of JPA Security.
  The first rule says that contacts can be accessed by the users they belong to.
  The second rule says that contacts can be accessed by users that are in the role of an administrator.
  The third rule says that users can be accessed by users that are in the role of an administrator.
          </p>
          <p>
  Let's try our program now and see what happens...
          </p>
        </section>
      </section>
    </section>
  </body>
</document>  