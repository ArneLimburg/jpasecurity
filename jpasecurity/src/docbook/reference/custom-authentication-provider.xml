<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE article PUBLIC "-//OASIS//DTD Simplified DocBook XML V1.1//EN" "http://www.oasis-open.org/docbook/xml/simple/1.1/sdocbook.dtd">
<article>
  <title>Implementing a custom Authentication Provider</title>
  <para>
	You can implement a custom authentication provider in a similar way like the access rules provider. 
	You only have to implement the interface <systemitem>net.sf.jpasecurity.security.AuthenticationProvider</systemitem>
	and specify the property <systemitem>net.sf.jpasecurity.security.authentication.provider</systemitem>
	in your <filename>persistence.xml</filename> with the classname of your implementation of the
	interface <systemitem>net.sf.jpasecurity.security.AuthenticationProvider</systemitem>.
    Take a look at its javadoc documentation for further reference.
  </para>
  <section>
    <title>Accessing persistence properties</title>
    <para>
      As your access rules provider your custom authentication provider may need additional configuration parameters, too.
      You also can define them via the persistence properties in your <filename>persistence.xml</filename>. Again you have
      to implement the interface <systemitem>net.sf.jpasecurity.persistence.PersistenceInformationReceiver</systemitem>
      to have the persistence properties injected when your authentication provider is initialized.      
    </para>
  </section>
  <section>
    <title>Example</title>
    <example>
      <title>Implementing a servlet-filter authentication provider</title>
      <para>
        The following code shows how to implement an authentication provider that reads its authentication information from
        the <systemitem>HttpSession</systemitem>.
      </para>
      <programlisting>
        <![CDATA[
public class AuthenticationFilter implements AuthenticationProvider, Filter {

    private static final String PRINCIPAL_ATTRIBUTE = "principal";
    private static final String ROLES_ATTRIBUTE = "roles";
    
    private static ThreadLocal<HttpSession> session = new ThreadLocal<HttpSession>();
    
    public Object getPrincipal() {
        HttpSession session = AuthenticationFilter.session.get();
        if (session == null) {
            return null;
        }
        return session.getAttribute(PRINCIPAL_ATTRIBUTE);
    }

    public Collection<?> getRoles() {
        HttpSession session = AuthenticationFilter.session.get();
        if (session == null) {
            return null;
        }
        return (Collection<?>)session.getAttribute(ROLES_ATTRIBUTE);
    }

    public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException {
        try {
            if (request instanceof HttpServletRequest) {
                HttpServletRequest httpRequest = (HttpServletRequest)request;
                AuthenticationFilter.session.set(httpRequest.getSession());
            }
            chain.doFilter(request, response);
        } finally {
            AuthenticationFilter.session.remove();
        }
    }

    public void init(FilterConfig config) throws ServletException {
    }

    public void destroy() {
    }
}
        ]]>          
      </programlisting>
      <para>
        You even can shorten your implementation by subclassing <systemitem>DefaultAuthenticationProvider</systemitem>.
      </para>
      <programlisting>
        <![CDATA[
public class AuthenticationFilter extends DefaultAuthenticationProvider implements AuthenticationProvider, Filter {

    private static final String PRINCIPAL_ATTRIBUTE = "principal";
    private static final String ROLES_ATTRIBUTE = "roles";

    public void doFilter(final ServletRequest request, final ServletResponse response, final FilterChain chain) throws IOException, ServletException {
        if (request instanceof HttpServletRequest) {
            HttpServletRequest httpRequest = (HttpServletRequest)request;
            Object principal = httpRequest.getAttribute(PRINCIPAL_ATTRIBUTE);
            Collection<?> roles = (Collection<?>)httpRequest.getAttribute(ROLES_ATTRIBUTE);
            runAs(principal, roles, new PrivilegedExceptionAction<Object>() {
                public Object run() throws Exception {
                    chain.doFilter(request, response);
                    return null;
                }
            });
        } else {
            chain.doFilter(request, response);
        }
    }

    public void init(FilterConfig config) throws ServletException {
    }

    public void destroy() {
    }
    
    private void runAs(Object principal, Collection<?> roles, PrivilegedExceptionAction<Object> action) throws IOException, ServletException {
        try {
            DefaultAuthenticationProvider.runAs(principal, roles, action);
        } catch (IOException e) {
            throw e;
        } catch (ServletException e) {
            throw e;
        } catch (Exception e) {
            throw new ServletException(e);
        }
    }
}
        ]]>          
      </programlisting>
      <para>
        For both implementations you now have to specify the class as web filter in your <filename>web.xml</filename>.
      </para>
      <programlisting>
        <![CDATA[
<?xml version="1.0" encoding="ISO-8859-1"?>
<web-app version="2.4"
         xmlns="http://java.sun.com/xml/ns/j2ee"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
		 xsi:schemaLocation="http://java.sun.com/xml/ns/j2ee http://java.sun.com/xml/ns/j2ee/web-app_2_4.xsd">

    ...

    <filter>
        <filter-name>authenticationFilter</filter-name>
        <filter-class>your.package.AuthenticationFilter</filter-class>
    </filter>

    <filter-mapping>
      <filter-name>authenticationFilter</filter-name>
      <url-pattern>/*</url-pattern>
    </filter-mapping>
    
    ...

</web-app>
        ]]>          
      </programlisting>
      <para>
        Now your login-process may store the authentication information (the principal and the roles)
        in the <systemitem>HttpSession</systemitem> and you are done. 
      </para>
    </example>
  </section>
</article>
