<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE article PUBLIC "-//OASIS//DTD DocBook XML V4.4//EN" "http://www.oasis-open.org/docbook/xml/4.4/docbookx.dtd">
<article id="security">
  <title>Adding Security</title>
  <para>
    In order to add access-control to our application we first need to integrate JPA Security.
  </para>
  <section>
    <title>Integrating JPA Security</title>
    <para>
      Integrating JPA Security is as simple as configuring the persistence provider:
    </para>
    <programlisting>
      <![CDATA[
<persistence-unit name="contacts" transaction-type="RESOURCE_LOCAL">

  <provider>net.sf.jpasecurity.persistence.SecurePersistenceProvider</provider>

  <class>net.sf.jpasecurity.contacts.User</class>
  <class>net.sf.jpasecurity.contacts.Contact</class>

  <properties>
    <property name="net.sf.jpasecurity.persistence.provider" value="org.hibernate.ejb.HibernatePersistence" />
    <property name="hibernate.hbm2ddl.auto" value="create-drop" />
    <property name="hibernate.dialect" value="org.hibernate.dialect.HSQLDialect" />
    <property name="hibernate.connection.driver_class" value="org.hsqldb.jdbcDriver" />
    <property name="hibernate.connection.url" value="jdbc:hsqldb:mem:contacts" />
    <property name="hibernate.connection.username" value="sa" />
    <property name="hibernate.connection.password" value="" />
  </properties>

</persistence-unit>
      ]]>
    </programlisting>
    <para>
      The following line has changed in order to use JPA Security:
    </para>
    <programlisting>
      <![CDATA[
<provider>net.sf.jpasecurity.persistence.SecurePersistenceProvider</provider>
      ]]>
    </programlisting>
    <para>
      The following line is added to specify the persistence provider:
    </para>
    <programlisting>
      <![CDATA[
    <property name="net.sf.jpasecurity.persistence.provider" value="org.hibernate.ejb.HibernatePersistence" />
      ]]>
    </programlisting>
    <para>
      OK, let's run our program again and let's see what happens...
    </para>
    <para>
      As you can see from the output: nothing happend, everything stayed as before.
      JPA Security smoothly integrated into our application, we even can't see it work.
      We have not defined access rules for now.
    </para>
  </section>
  <section>
    <title>Defining access rules</title>
    <para>
      We define access rules by annotating our domain objects:
    </para>
    <programlisting>
      <![CDATA[
@Entity
@DeclareRoles({"admin", "user"})
@RolesAllowed("admin")
@PermitWhere(value = "name = CURRENT_PRINCIPAL")
public class User {
    ...
}
      ]]>
    </programlisting>
    <programlisting>
      <![CDATA[
@Entity
@RolesAllowed("admin")
@PermitWhere("owner.name = CURRENT_PRINCIPAL")
public class Contact {
    ...
}
      ]]>
    </programlisting>
    <para>
      We have added three annotations to <programlisting>User</programlisting> and two annotations to <programlisting>Contact</programlisting>:
      <itemizedlist>
        <listitem>
          <programlisting>@DeclareRoles({"admin", "user"})</programlisting>
          This annotation tells JPA Security that we are going to use the roles "admin" and "user".
          We must declare these roles at least at one entity.
        </listitem>
        <listitem>
          <programlisting>@RolesAllowed("admin")</programlisting>
          This annotation was added to both classes. With it we specify that every user
          that is in the role admin may create, read, update or delete entities of the types
          <programlisting>User</programlisting> and <programlisting>Contact</programlisting>.
        </listitem>
        <listitem>
          <programlisting>@PermitWhere(value = "name = CURRENT_PRINCIPAL")</programlisting>
          We annotated only the <programlisting>User</programlisting> class with this annotation. It specifies,
          that access to a <programlisting>User</programlisting> is permitted when the name of the user is the
          same as the current principal. In other words: Every user may access its own
          <programlisting>User</programlisting> object.
        </listitem>
        <listitem>
          <programlisting>@PermitWhere(value = "owner.name = CURRENT_PRINCIPAL")</programlisting>
          This annotation was added only to the <programlisting>Contact</programlisting> class.
          We specify, that access to a <programlisting>Contact</programlisting> is permitted when the name
          of the owner is the same as the current principal. In other words: Every user
          may access its own <programlisting>Contact</programlisting> objects.
        </listitem>
      </itemizedlist>      
      These access rules that show the capability of JPA Security. We have specified,
      that a <programlisting>User</programlisting> object may be accessed either by an admin or by the user
      represented by that object. For the <programlisting>Contact</programlisting> objects we have specified
      that they may be accessed by admins, too and that they may be accessed by their owners.
    </para>
    <para>
      Let's try our program now and see what happens...
    </para>
    <para>
      As we can see an exception is thrown, a <programlisting>javax.persistence.NoResultException</programlisting>
      at the line where we try to select john from the database. That's great. We should have expected this,
      as we are not authenticated and thus not permitted to select john from the database.
	  An additional output proves this, as we can see the number of users we get displayed
	  by our <programlisting>displayUserCount</programlisting> method is actually 0.
    </para>
  </section>
  <section>
    <title>Using runAs</title>
    <para>
      Apparently we need admin rights to create contacts (to access all users), that means we must
      run the <programlisting>createContacts</programlisting> method as admin. We can to this by using the <programlisting>runAs</programlisting>
      method of the <programlisting>StaticAuthenticationProvider</programlisting>. We change the method <programlisting>createContacts</programlisting>
      to run as user "root" with the role "admin":
    </para>
    <programlisting>
  public static void createContacts(final EntityManagerFactory entityManagerFactory) {
    StaticAuthenticationProvider.runAs("root", Arrays.asList("admin"), new PrivilegedAction() {
      public Object run() {
        EntityManager entityManager;

        entityManager = entityManagerFactory.createEntityManager();
        entityManager.getTransaction().begin();
        User john = (User)entityManager.createQuery("SELECT user FROM User user WHERE user.name = 'John'").getSingleResult();
        User mary = (User)entityManager.createQuery("SELECT user FROM User user WHERE user.name = 'Mary'").getSingleResult();
        entityManager.persist(new Contact(john, "peter@jpasecurity.sf.net"));
        entityManager.persist(new Contact(john, "0 12 34 - 56 789"));
        entityManager.persist(new Contact(mary, "paul@jpasecurity.sf.net"));
        entityManager.persist(new Contact(mary, "12 34 56 78 90"));
        entityManager.getTransaction().commit();
        entityManager.close();
        return null;
      }
    });
  }
    </programlisting>
  </section>
  <section>
    <title>Authentication</title>
    <para>
      When we now run the application, we see that the exception is gone away, but when we take a look at
      the output of our <programlisting>displayUserCount</programlisting> and <programlisting>displayContactCount</programlisting> method is actually 0.
      This is because we just authenticated for the <programlisting>createContacts</programlisting> method. Let's authenticate
      as "root" with the role admin at the beginning of the <programlisting>main</programlisting> method:
    </para>
    <programlisting>
  public static void main(String[] args) {
    StaticAuthenticationProvider.authenticate("root", "admin");
    EntityManagerFactory entityManagerFactory = Persistence.createEntityManagerFactory("contacts");
    createUsers(entityManagerFactory);
    displayUserCount(entityManagerFactory);
    createContacts(entityManagerFactory);
    displayContactCount(entityManagerFactory);
  }
    </programlisting>
    <para>
      When we now run our program we can see from the output, that we get 2 users and 4 contacts.
      This is what we expected, as we are permitted to select all data with the role "admin".
    </para>
    <para>
      But what is, when we authenticate as "John"? Let's try...
    </para>
    <programlisting>
  public static void main(String[] args) {
    StaticAuthenticationProvider.authenticate("John");
    EntityManagerFactory entityManagerFactory = Persistence.createEntityManagerFactory("contacts");
    createUsers(entityManagerFactory);
    displayUserCount(entityManagerFactory);
    createContacts(entityManagerFactory);
    displayContactCount(entityManagerFactory);
  }
    </programlisting>
    <para>
      Now the output says that we get no user and 2 contacts (that are Johns contacts). We get only one
      user because we are only allowed to retrieve our own <programlisting>User</programlisting> object.
      Obviously JPA Security works: It filters out the users and contacts we are not allowed to see.
      We may authenticate as "Mary" and see that it works, too.
    </para>
    <para>
      Congratulations, you have successfully set up and worked with JPA Security.
      Next steps may be to read the manual, try the petclinic tutorial or take a look at the API-Documentation.
    </para>
  </section>
</article>
