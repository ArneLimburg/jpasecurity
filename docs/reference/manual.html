<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><title>JPA Security Manual</title><meta name="author" content="null" /><meta name="date" content="null" /></head><body><h1>1. Preamble</h1><div class="section"><p>
    Developing enterprise software applications with security requirements 
    can be a cumbersome and error-prone process. In such applications often
    the security is spread all over the application code. This makes it difficult
    to understand how things work and hard to maintain security in such code.
  </p>
  <p>
    With model-driven development business logic should be expressed in the objects of your domain model.
    As for now there is no convenient way to express access control requirements through your domain model.
    Hence access control-code is normally written into the service layer or data-access layer.
  </p>
  <p>
    JPA Security offers a way to express access control through your domain model
    and additionally supplies a solution to completely separate access control logic from business logic,
    improving performance and maintainability.
    JPA Security provides an interface to define security requirements of your
    domain model via configuration (Annotations or XML).
  </p>
  <p>
	Due to it's smooth integration into current Java standards,
	it may be integrated into every layer of your application.
	<!-- It enables you to configure rules defining access control for your Java Beans
	(like JSF 2 Managed Beans, CDI Beans, EJBs and JPA 2 Entity Beans or Embeddables) -->
	It enables you to configure rules defining access control for your Entity Beans and Embeddables
    based on the current security context
    (i.e. the currently authenticated user and/or its roles in the application).
  </p>
  <p>
    JPA Security uses the notion of <i>security unit</i> to refer
    to a set of Java bean classes and their corresponding access rules.
    <!-- A security unit
    may be completely decoupled from other concepts like this in the Java universe,
    but it may correspond i.e. to a servlet context (in a web environment)
    or to a persistence context (in a JPA environment). -->
    In the current version of JPA Security a security unit directly corresponds to a
    persistence unit of JPA.
    The content of a security unit is defined at deployment time and may not change at runtime.
  </p>
  <p>
    In contrast to the <i>security unit</i>, the <i>security context</i>
    starts at runtime with the authentication of a user. As of version 0.4.0 of JPA Security
    the content of this context is completely customizable and you can do so by implementing the
    <tt>SecurityContext</tt> interface. The security context
    contains information like i.e. the current user, its roles and/or the current tenant,
    but any kind of context information that is needed to specify the authorization of the current
    user to access beans may be made available through the security context.
  </p>
  <p>
    JPA Security smoothly integrates with existing authentication solutions like specified in the
    servlet specification, with EJB or Spring Security. JPA Security may be configured to
    take the current user and its roles provided by this technologies and fill the security context with it.
  </p>
</div><h1>2. Basics - Rules, Users and Roles</h1><div class="section"><p>
    Authorization is the process of giving someone permission to do or see something.
    It is used to determine what the authenticated user is allowed to do in the application
    and what data he is allowed to see.
  </p>
  <div class="section">
    <h2>Organizing Authorization</h2>
    <p>
	  There are different ways of organizing authorization.
      Widely used approaches are role-based authorization or access control lists.
    </p>
    <ul>
      <li>
        
          In role-based Authorization users are assigned to roles. Rights to do or get something are granted to these roles.
        
      </li>
      <li>
        
          In the concept of &quot;Access Control Lists&quot;
          an access control list is assigned to every object that has to be accessed.
          An access control list is a list of access control entries. Every of
          this entries holds a reference to a user or a role it is valid for,
          as well as the access rights that the referenced user or role has on
          the object.
                  
      </li>
    </ul>
    <!-- example>
      <title>Example:</title>
      Let there be the following business requirements:
      <itemizedlist>
        <listitem>Administrators may get (i.e. view) TestBeans</listitem>
        <listitem>Administrators may delete TestBeans</listitem>
        <listitem>Users may own TestBeans</listitem>
        <listitem>Users may get (i.e. view) their owned TestBeans</listitem>
      </itemizedlist>
      In this scenario we have two roles: administrator and user.
      With JavaEE you may solve this at the session-bean level by some session bean like this:
      <programlisting>
        @Stateless
        public class TestBeanDao {
         	
          	@PersistenceContext
            	private EntityManager entityManager;
              	
               	@RolesAllowed("administrator");
               	public List&lt;TestBean&gt; getAllTestBeans() {
               		return entityManager.createQuery("SELECT t FROM TestBean t")
               		                    .getResultList();
               	}
               	
               	@RolesAllowed("administrator");
               	public void deleteTestBean(TestBean testBean) {
               		entityManager.remove(testBean);
               	}
                	
               	@RolesAllowed("user");
               	public List&lt;TestBean&gt; getTestBeansForUser(User user) {
               		return entityManager.createQuery("SELECT t FROM TestBean t WHERE t.owner = :user")
               		                    .setParameter("user", user)
               		                    .getResultList();
               	}
              }
      </programlisting>
    </example -->
  </div>
  <div class="section">
    <h2>Access Control: Authorization in Action</h2>
    <p>
      Access Control is the process of allowing and forbidding access to resources
      based on the authorization of the current security context. There are different
      levels of access control.
    </p>
    <ul>
      <li>
        
          Presentation left access control - Access control is implemented
          in the presentation tier of the application. Only data that the
          user is allowed to see is displayed and only buttons for actions
          that the user is allowed to do are displayed and enabled. Although
          it may be necessary to provide different views to users with
          different roles, handling access control only at the presentation
          layer can be a big problem, when it involves loading and 
          transferring masses of data to the presentation layer,
          where it gets filtered out, because the current user is not allowed
          to see it.
        
      </li>
      <li>
        
          Service level access control - Access control is implemented in
          the service tier. Often this is realized using method-based
          access control. For every method in the service tier it is defined
          which users and/or roles are allowed to call it. Although this kind
          of security is widely supported by current security solutions like
          JavaEE Security and Spring Security it is often not the correct location
          of handling access control because access control usually depends
          more on the data used than on the actions executed. This leads to
          code that checks the current user and/or its roles to decide which
          data access tier method to invoke or this kind of checks are done
          by the code invoking the service methods. However manual handling
          of authorization informations leads to spreading the security all
          over the code. This makes changes to security requirements hard to handle.
        
      </li>
      <li>
        
          Class level access control - Using class level access control on
          the entity beans of an application leads to a more fine-graded
          access control mechanism. If you are able to define which
          entity types may be used by which user or role (and you can do this
          in EJB 3 with the <i><tt>@RolesAllowed</tt></i> annotation) you have a clean way
          of defining which user may see and/or change which data without
          manual handling of authorization information. However this level
          is not detailed enough in many cases.
        
      </li>
      <li>
        
          Instance level access control - With instance level access control
          for every user and/or role you can define permissions on an entity
          basis. Access Control Lists
          are widely used for this approach, but JPA Security provides a more
          flexible way to accomplish this, like we see later.
        
      </li>
      <li>
        
          Property level access control - A step further from instance level
          access control is property level access control, where you can define
          access restrictions on a property base. JPA Security currently only supports
          property level access control for properties of type <i><tt>@Embeddable</tt></i>
          by providing instance level access control for embeddables.
        
      </li>
    </ul>
  </div>
  <div class="section">
    <h2>Access Control in JPA Security</h2>
    <p>
      In JPA Security the access to entities and embeddables is defined by access rules.
      There is one set of access rules per security unit. This set of access rules
      applies to every JPA query and every entity and embeddable you get out of an
      <i><tt>EntityManager</tt></i> of the persistence unit that corresponds
      to that security unit.
    </p>
    <div class="section">
      <h3>Example: Access Rule</h3>
      <p>
        The following rule restricts the read access to accounts,
        where the owner is equal to the current user. In other words:
        every user can read only its own accounts.
      </p>
      <div class="source"><pre>
        GRANT READ ACCESS TO Account account WHERE account.owner = CURRENT_PRINCIPAL
      </pre></div>
      <p>
        In the previous example the <tt>CURRENT_PRINCIPAL</tt> is provided
        by the currently active security context. When the access rule is evaluated, the
        <tt>CURRENT_PRINCIPAL</tt> is received from the security context
        and the rule is evaluated against this principal
      </p>
    </div>
    <div class="section">
      <h3>Access Rules in JPA Security</h3>
      <p>
        JPA Security allows the definition of rules that grant create, read, update and/or delete access.
        Currently there is no explicit way to deny access. Although this is not needed,
        since every entity or embeddable to which no access is granted may not be accessed.
        An exception from this behavior are classes for which no access rule exists at all.
        Objects of such class may be accessed without any restriction.
      </p>
    </div>
    <div class="section">
      <h3>The syntax of access rules</h3>
      <p>
        The general syntax of an access rule of JPA Security looks like <b>GRANT [CREATE] [READ] [UPDATE] [DELETE] ACCESS TO </b>
        <i><tt>entity_name alias</tt></i> <b>[</b><i><tt>where_clause</tt></i><b>]</b>,
	    where <i><tt>entity_name</tt></i> must be an entity or embeddable of the persistence unit (according to the JPA Specification,
        defaults to the class name if not otherwise specified) and the <i><tt>alias</tt></i> is an alias for that entity or embeddable
        that may be used in the where clause.
      </p>
      <p>
	    The syntax of the <i><tt>where_clause</tt></i> is derived from the syntax of <b>WHERE</b> clauses of JPQL, the query
        language of JPA. Within the clause any alias may be used that is defined by your current security context. The build-in security contexts
        define two aliases, which are <b>CURRENT_PRINCIPAL</b> and <b>CURRENT_ROLES</b>.
        The <b>CURRENT_PRINCIPAL</b> alias will be evaluated to the currently authenticated
        principal during runtime and the <b>CURRENT_ROLES</b> alias will be expanded to a list
        of roles that the current principal belongs to. No input parameters may be used in the <b>WHERE</b> clause of access rules.
        If you need more aliases to be defined (i.e. <b>CURRENT_TENANT</b>),
        you will have to implement your own security context like described later.
      </p>
    </div>
    <div class="section">
      <h3>Providing access rules</h3>
      <p>
        With JPA Security there are two predefined ways to provide access rules:
        via XML configuration or via Annotations. In a later chapter we will see 
        how to implement your own way of providing access rules.
      </p>
      <div class="section">
        <h4>Access rules via XML</h4>
        <p>
          One predefined way to provide access rules in JPA Security is via a file
          called <tt>security.xml</tt>, which is located in the <tt>META-INF</tt>
          directory of your application. Below is an example of the structure of such file:
        </p>
        <div class="source"><pre>
&lt;security xmlns=&quot;http://jpasecurity.sf.net/xml/ns/security&quot;
          xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
          xsi:schemaLocation=&quot;http://jpasecurity.sf.net/xml/ns/security
                              http://jpasecurity.sf.net/xml/ns/security/security_1_0.xsd&quot;
          version=&quot;1.0&quot;&gt;

  &lt;persistence-unit name=&quot;...&quot;&gt;
    &lt;access-rule&gt;...&lt;/access-rule&gt;
    ...
  &lt;/persistence-unit&gt;
&lt;/security&gt;
        </pre></div>
      </div>
      <div class="section">
        <h4>Access rules via Annotations</h4>
        <p>
          The other predefined way to provide access rules in JPA Security is via Annotations.
          You may annotate your entity classes with one of the following two annotations:
          <i><tt>javax.annotation.security.RolesAllowed</tt></i> and
          <i><tt>org.jpasecurity.security.rules.Permit</tt></i>.
        </p>
        <p>
          Note that the semantics of the <i><tt>@RolesAllowed</tt></i> annotation slightly differs
          between the EJB Specification and JPA Security: If you annotate a class with the
          <i><tt>@RolesAllowed</tt></i> annotation this means for EJB any access to any method
          of an instance of that class will cause a <i><tt>SecurityException</tt></i>, if the
          current user is not in one of the roles allowed. JPA Security goes a step further:
          The current user will not retrieve this object from database if he is not in one of
          the roles allowed. JPA Security does not support the <i><tt>@RolesAllowed</tt></i>
          annotation at method-level.
        </p>
        <p>
          The <i><tt>@Permit</tt></i> annotation has two optional parameters:
        </p>
        <ul>
          <li>
            
              With the parameter <i><tt>access</tt></i> you can specify
              which kind of access shall be granted by this rule.
              The value is an array of the <i><tt>AccessType</tt></i> enum. 
              Possible values of an <i><tt>AccessType</tt></i> are
              <i><tt>CREATE</tt></i>, <i><tt>READ</tt></i>,
              <i><tt>UPDATe</tt></i> and <i><tt>DELETE</tt></i>.
            
          </li>
          <li>
            
              With the parameter <i><tt>rule</tt></i> you can specify a
              rule to restict the access for entities of the annotated class.
              The syntax of this rule is derived from the
              <i><tt>where</tt></i>-clause of JPQL (see previous section),
              where the special keyword <i><tt>this</tt></i> serves as an
              alias for the annotated entity or embeddable that may be used in the rule.
            
          </li>
        </ul>
        <p>
          Example:
        </p>
        <div class="source"><pre>
@Permit(access = AccessType.READ, rule = &quot;owner = CURRENT_PRINCIPAL&quot;)
public class Account {
    ...
}
        </pre></div>
      </div>
      <div class="section">
        <h4>Applying of access rules</h4>
        <p>
          Read-access rules are applied to every entity or embeddable that is accessed via a
          JPA-Security-enabled <i><tt>EntityManager</tt></i> or via object-navigation
          through objects obtained from such <i><tt>EntityManager</tt></i>. 
          When the object is accessed via JPQL, the access rules are applied
          directly to the JPQL-query, allowing the filtering to take place within the database.
          When the object is accessed via object-navigation, JPA Security tries to avoid database-calls
          and evaluates the rules in memory. When in-memory-evaluation is not applicable and the
          entity-manager is still open, a query is performed to evaluate the query.
          In the next section you can read, in which cases in-memory-evaluation is applicable and
          where not. 
          When in-memory-evaluation is not applicable and the entity-manager is already closed,
          a <i><tt>SecurityException</tt></i> will be thrown.
        </p>
        <p>
		  Update-access rules are applied on <i><tt>flush()</tt></i> or <i><tt>commit()</tt></i>.
		  Again the default-behaviour is in-memory-evaluation then, falling back to a query like described above.
        </p>
        <p>
          Create-access rules and delete-access rules are applied when the appropriate action is performed
          with the entity-manager (either direct or by cascading). In-memory-evaluation applies like described above.
        </p>
        <p>
          For all cases JPA Security is clever enough to apply the appropriate access rules for sub-
          and superclasses, too.
        </p>
      </div>
      <div class="section">
        <h4>In-Memory-Evaluation</h4>
        <p>
          Every access rule that does not contain any sub-select can be evaluated in memory.
          For queries that contain sub-selects it depends on the kind of the sub-select
          and the content of the (first-level) entity-manager-cache of JPA Security.
          Sub-selects where all aliases from within the sub-select can directly replaced with
          an alias from outside can be evaluated in memory. Thus the following access rule
          can be evaluated in memory: 
        </p>
        <div class="source"><pre>
          
GRAND ACCESS TO TestBean bean WHERE EXISTS (SELECT b FROM TestBean b WHERE b = bean AND b.accessControlList = CURRENT_PRINCIPAL)
          
        </pre></div>
<!-- TODO: Test this restriction, it is likely to be gone
        <para>
          Sub-selects that contain collection-joins cannot directly evaluated in memory and the
          result of the evaluation depends on the content of the (first-level) entity-manager-cache.
          Thus the following query cannot be evaluated in memory:
        </para>
        <programlisting>
          <![CDATA[
GRAND ACCESS TO TestBean bean WHERE EXISTS (SELECT b FROM TestBean b, IN(b.accessControlList.entries) entry WHERE b = bean AND entry IN (CURRENT_ROLES)
          ]]>
        </programlisting> -->
        <p>
          Since the alias from within the sub-select cannot directly replaced by the alias from outside,
          the following query cannot be evaluated in memory:
        </p>
        <div class="source"><pre>
          
GRAND ACCESS TO TestBean bean WHERE EXISTS (SELECT entry FROM AccessControlListEntry entry WHERE bean.accessControlList = entry.accessControlList AND entry IN (CURRENT_ROLES)
          
        </pre></div>
        <p>
		  Although there can be no guarantee in general that the last query can be evaluated in memory,
		  in-memory-evaluation can still be achieved by ensuring that the entities that are needed to evaluate
		  the sub-select are contained in the (first-level) entity-manager-cache. For example the last rule
		  can be evaluated in memory if there exists an <i><tt>AccessContolListEntry</tt></i> in the
		  cache that meets the specified where-clause. Remember, that on persist the check will be done
		  before the persist-operation is cascaded. So when you want to persist a <i><tt>TestBean</tt></i>
		  that contains an <i><tt>accessControlList</tt></i> with entries that match the where-clause,
		  you have to persist the entries before you persist the <i><tt>TestBean</tt></i> to ensure
		  the entries are in the cache. 
        </p>
      </div>
    </div>
  </div>
</div><div class="section"><p>
    Authentication is the process of determining and verifying
    the identity of someone or something. In multi-user applications,
    the process of authentication for an application is needed to get
    knowledge about the person that is currently using the application.
    The widely used process for authentication is a login process during
    which the user is asked for his username and password.
    A user that knows one of this username/password-tuples is assumend
    to be the person belonging to that username. Besides
    username/password authentication there are other methods like
    public-key-authentication with a digital certificate, to name just one.
  </p>
  <div class="section">
    <h2>Authentication in JPA Security</h2>
    <p>
      JPA Security uses an implementation of the
      <i><tt>org.jpasecurity.configuration.SecurityContext</tt></i>
      interface to be aware of the currently authenticated user
      and other related information (like its roles, tenant, ...) at runtime.
    </p>
    <div class="section">
      <h3>Default-Configuration for Authentication</h3>
      <p>
        By default JPA Security will try to auto-detect your security context.
        This is done via the indirection of an authentication provider. An authentication
        provider provides access to the current authenticated user and its roles.
        The detection follows the following rules (The first matching rule is taken): 
      </p>
      <ol style="list-style-type: decimal">
        <li>
          
            When spring-security is in the classpath, the <i><tt>SpringAuthenticationProvider</tt></i> is used.
          
        </li>
        <li>
          
            When <i><tt>java:comp/EJBContext</tt></i> is available in the JNDI-context,
            the <i><tt>EjbAuthenticationProvider</tt></i> is used.
          
        </li>
        <li>
          
            When JSF is available in the classpath, the <i><tt>JsfAuthenticationProvider</tt></i> is used.
          
        </li>
        <li>
          
            Otherwise the <i><tt>DefaultAuthenticationProvider</tt></i> is used.
          
        </li>
      </ol>
    </div>
    <div class="section">
      <h3>Customizing Authentication</h3>
      <p>
        When the described auto-detection strategy does not work for your environment,
        you may specify the class name of any implementation of the
        <i><tt>org.jpasecurity.configuration.SecurityContext</tt></i> interface as value
        of the persistence-property <i><tt>org.jpasecurity.security.context</tt></i>
        in your <tt>persistence.xml</tt>. To provide backward compatibility to JPA Security 0.3
        <i><tt>org.jpasecurity.security.authentication.provider</tt></i> is also valid,
        if you specify a class name of an implementation of the
        <i><tt>org.jpasecurity.configuration.AuthenticationProvider</tt></i> interface,
        but any specification of the <i><tt>org.jpasecurity.security.context</tt></i> property
        will take precedence.
      </p>
    </div>
  </div>
</div><h1>3. Getting started with JPA Security</h1><div class="section"><p>
    In order to use JPA Security you have to enable it for your persistence unit. This can be done
    by modifying your &quot;persistence.xml&quot; to point to JPA Security.
    Additionally you have to configure JPA Security to use your original persistence provider.
  </p>
<!-- <itemizedlist> -->
<!-- <listitem> -->
<!-- <para> -->
<!-- <systemitem>org.jpasecurity.persistence.provider</systemitem> -->
<!-- - The value of this property may be your original persistence provider -->
<!-- </para> -->
<!-- </listitem> -->
<!-- <listitem> -->
<!-- <para> -->
<!-- <systemitem>org.jpasecurity.security.authentication.provider</systemitem> -->
<!-- - The value of this property may be an implementation of -->
<!-- <systemitem>org.jpasecurity.security.authentication.AuthenticationProvider</systemitem> -->
<!-- </para> -->
<!-- </listitem> -->
<!-- <listitem> -->
<!-- <para> -->
<!-- <systemitem>org.jpasecurity.security.rules.provider</systemitem> -->
<!-- - The value of this property may be an implementation of -->
<!-- <systemitem>org.jpasecurity.security.rules.AccessRulesProvider</systemitem> -->
<!-- </para> -->
<!-- </listitem> -->
<!-- </itemizedlist> -->
  
    persistence.xml Example
    <p>
      Supposed you have an existing JPA application. Your <tt>persistence.xml</tt>
      may look similar to this:
    </p> 
    <div class="source"><pre>
      
&lt;persistence xmlns=&quot;http://java.sun.com/xml/ns/persistence&quot;
             xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
             xsi:schemaLocation=&quot;http://java.sun.com/xml/ns/persistence
                                 http://java.sun.com/xml/ns/persistence/persistence_1_0.xsd&quot;
             version=&quot;1.0&quot;&gt;
          
  &lt;persistence-unit name=&quot;your-persistence-unit-name&quot; transaction-type=&quot;...&quot;&gt;

    &lt;provider&gt;your.persistence.provider.ClassName&lt;/provider&gt;

    &lt;class&gt;your.persistent.ClassName&lt;/class&gt;
    &lt;!-- More class-mappings go here --&gt;
    ...
                
    &lt;properties&gt;
      &lt;!-- persistence-provider-specific properties go here --&gt;
      ...
    &lt;/properties&gt;

  &lt;/persistence-unit&gt;
&lt;/persistence&gt;
                
    </pre></div>
    <p>
      After integrating JPA Security your &quot;persistence.xml&quot;
      may look like this:
    </p>
    <div class="source"><pre>
      
&lt;persistence xmlns=&quot;http://java.sun.com/xml/ns/persistence&quot;
             xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
             xsi:schemaLocation=&quot;http://java.sun.com/xml/ns/persistence
                                 http://java.sun.com/xml/ns/persistence/persistence_1_0.xsd&quot;
             version=&quot;1.0&quot;&gt;
          
  &lt;persistence-unit name=&quot;your-persistence-unit-name&quot; transaction-type=&quot;...&quot;&gt;

    &lt;provider&gt;org.jpasecurity.persistence.SecurePersistenceProvider&lt;/provider&gt;

    &lt;class&gt;your.persistent.ClassName&lt;/class&gt;
    &lt;!-- More class-mappings go here --&gt;
    ...
                
    &lt;properties&gt;
      &lt;property name=&quot;org.jpasecurity.persistence.provider&quot;
                value=&quot;your.persistence.provider.ClassName&quot; /&gt;
      &lt;!-- persistence-provider-specific properties go here --&gt;
      ...
    &lt;/properties&gt;

  &lt;/persistence-unit&gt;
&lt;/persistence&gt;
                
    </pre></div>
    <p>
      We changed the &lt;provider&gt; tag to point to JPA Security's
      implementation of the <i><tt>PersistenceProvider</tt></i> interface
      and added the property <i><tt>org.jpasecurity.persistence.provider</tt></i>
      to point to your original persistence provider. That is all you need to integrate JPA Security.
    </p>
  
</div><div class="section"><p>
    To use Java EE authentication information for JPA Security you may integrate JPA Security like
    described in the previous chapter and specify
    <i><tt>org.jpasecurity.security.authentication.EjbAuthenticationProvider</tt></i>
    as authentication provider in your persistence properties.
    You need to define all the roles your application is using
    with the <i><tt>@DeclareRoles</tt></i> annotation at at least one of your entity beans
    in order to make the <i><tt>EjbAuthenticationProvider</tt></i> work correctly.
  </p>
  <p>
    If you do not have a version of a <tt>spring-security.jar</tt> in your classpath
    usually you do not need to define your own authentication provider as the auto-detection
    mechanism of JPA Security should automatically install the <i><tt>EjbAuthenticationProvider</tt></i>.
  </p>
</div><div class="section"><p>
    To use Servlet authentication information for JPA Security within your JSF application
    you may integrate JPA Security like described in the previous chapter and specify
    <i><tt>org.jpasecurity.jsf.authentication.JsfAuthenticationProvider</tt></i>
    as authentication provider in your persistence properties.
    You need to define all the roles your application is using
    with the <i><tt>@DeclareRoles</tt></i> annotation at at least one of your entity beans
    in order to make the <i><tt>JsfAuthenticationProvider</tt></i> work correctly.
  </p>
  <p>
    If you do not have a version of a <tt>spring-security.jar</tt> in your classpath
    usually you do not need to define your own authentication provider as the auto-detection
    mechanism of JPA Security should automatically install the <i><tt>EjbAuthenticationProvider</tt></i>
    (if you are in a Java EE server) or the <i><tt>JsfAuthenticationProvider</tt></i> if you are
    using JSF outside a Java EE server, both using Servlet authentication information.
  </p>
  <p>
    You need to have the jpasecurity-jsf module in your classpath
    in order to make the <i><tt>JsfAuthenticationProvider</tt></i> work.
  </p>
</div><div class="section"><p>
    If you are using the Spring-framework with Spring Security,
    you don't have to follow the chapter <i>Getting started with JPA Security</i>
    (also you can do and specify the
    <i><tt>org.jpasecurity.security.authentication.SpringAuthenticationProvider</tt></i> in your
    persistence.properties).
  </p>
  <p>
	The easiest way to integrate Spring-Security is to simply replace your
    <i><tt>LocalEntityManagerFactoryBean</tt></i> or <i><tt>LocalContainerEntityManagerFactoryBean</tt></i>
    in your Spring configuration with the appropriate counterpart in the
    <i><tt>org.jpasecurity.spring.persistence</tt></i> package (which are <i><tt>SecureLocalEntityManagerFactoryBean</tt></i>
    and <i><tt>SecureContainerEntityManagerFactoryBean</tt></i>).
  </p>
  <p>
    The autodetection mechanism of JPA Security will automatically detect that you are using Spring Security,
    but you can specify your security context or authentication provider as bean property
    of the <i><tt>Secure*EntityManagerFactoryBean</tt></i> in your spring configuration.
  </p>
  <p>
    You need to have the jpasecurity-spring module in your classpath to use spring security.
  </p>
</div><div class="section"><p>
    If you neither use Java EE authentication nor Servlet authentication (via JSF) nor Spring-Security
    you either have to provide your own implementation of the
    <i><tt>org.jpasecurity.configuration.SecurityContext</tt></i> interface
    or you have to use one of the build-in authentication providers, which are
    <i><tt>DefaultAuthenticationProvider</tt></i> and <i><tt>StaticAuthenticationProvider</tt></i>.
  </p>
  <p>
    Both provide methods to authenticate users and roles and methods to apply <i><tt>runAs</tt></i> behavior.
    The <i><tt>DefaultAuthenticationProvider</tt></i> may be used in server-site applications
    where the authentication is on a per-thread-basis whereas the <i><tt>StaticAuthenticationProvider</tt></i>
    may be used on client-site applications where authentication per vm is intended.
  </p>
  <p>
    You may take a look at the simple tutoral to see an example of using the <i><tt>StaticAuthenticationProvider</tt></i>.
    In the next chapter you will learn how to provide a custom security context or authentication provider.
  </p>
</div><h1>4. Customization</h1><div class="section"><p>
    JPA Security is configured via the persistence properties in your <tt>persistence.xml</tt>.
    Below is a list of persistence properties that are supported out of the box by JPA Security.
  </p>
  <ul>
    <li>
      
        <i><tt>org.jpasecurity.persistence.provider</tt></i> - This is the only property
        that is required by JPA Security. It specifies the class name of the original persistence provider
        that shall be used by JPA Security to do the actual database access. 
      
    </li>
    <li>
      
        <i><tt>org.jpasecurity.security.authentication.provider</tt></i> - This property specifies
        the class name of the implementation of an authentication provider which may be any implementation of
        the interface <i><tt>org.jpasecurity.configuration.AuthenticationProvider</tt></i>.
      
    </li>
    <li>
      
        <i><tt>org.jpasecurity.security.context</tt></i> - This property specifies
        the class name of the implementation of a security context which may be any implementation of
        the interface <i><tt>org.jpasecurity.configuration.SecurityContext</tt></i>.
      
    </li>
    <li>
      
        <i><tt>org.jpasecurity.security.rules.provider</tt></i> - This property specifies
        the class name of the implementation of an access rules provider which may be any implementation of
        the interface <i><tt>org.jpasecurity.configuration.AccessRulesProvider</tt></i>.
      
    </li>
  </ul>
</div><div class="section"><p>
    As stated before you may implement your own way of providing access rules (i.e. via JDBC).
	You have to implement the interface <i><tt>org.jpasecurity.security.rules.AccessRulesProvider</tt></i>
	and specify the property <i><tt>org.jpasecurity.security.rules.provider</tt></i>
	in your <tt>persistence.xml</tt> with the classname of your implementation of the
	interface <i><tt>org.jpasecurity.security.rules.AccessRulesProvider</tt></i>.
    Take a look at its javadoc documentation for further reference.
  </p>
  <div class="section">
    <h2>Accessing persistence properties</h2>
    <p>
      Your custom access rules provider may need additional configuration parameters. You can define them
      via the persistence properties in your <tt>persistence.xml</tt>. All you have to do, is to implement
      the interface <i><tt>org.jpasecurity.persistence.PersistenceInformationReceiver</tt></i>.
      Then you will have the persistence properties injected when your persistence provider is initialized.      
    </p>
  </div>
  <div class="section">
    <h2>Implementing an Access Rules Provider</h2>
    <p>
      When you take a look at the methods of <i><tt>org.jpasecurity.rules.AccessRulesProvider</tt></i>,
      you may notice that you need to create objects of type
      <i><tt>org.jpasecurity.security.AccessRule</tt></i>. This objects may be created using a
      <i><tt>org.jpasecurity.jpql.parser.JpqlParser</tt></i> in conjunction with an
      <i><tt>org.jpasecurity.security.rules.AccessRulesCompiler</tt></i>, but you may subclass
      <i><tt>org.jpasecurity.security.rules.AbstractAccessRulesProvider</tt></i>
      to inherit this functionality. Then you have to override <i><tt>initializeAccessRules</tt></i>
      and call <i><tt>compileRules</tt></i> from within.
    </p>
  </div>
  <div class="section">
    <h2>Example</h2>
    
      <h2>Implementing a JDBC access rules provider</h2>
      <p>
        The following code shows how to implement an access rules provider that reads its access rules from a database.
        You may specify the needed parameters in your <tt>persistence.xml</tt>.
      </p>
      <div class="source"><pre>
        
public class JdbcAccessRulesProvider extends AbstractAccessRulesProvider {

  public static final String ACCESS_RULES_JDBC_URL_PROPERTY = &quot;org.jpasecurity.security.rules.jdbc.url&quot;;
  public static final String ACCESS_RULES_JDBC_USERNAME_PROPERTY = &quot;org.jpasecurity.security.rules.jdbc.username&quot;;
  public static final String ACCESS_RULES_JDBC_PASSWORD_PROPERTY = &quot;org.jpasecurity.security.rules.jdbc.password&quot;;  
  public static final String ACCESS_RULES_JDBC_TABLE_PROPERTY = &quot;org.jpasecurity.security.rules.jdbc.table&quot;;
  public static final String ACCESS_RULES_JDBC_COLUMN_PROPERTY = &quot;org.jpasecurity.security.rules.jdbc.column&quot;;

  protected void initializeAccessRules() {
    Map&lt;String, String&gt; properties = getPersistenceProperties();
    String url = getPersistenceProperty(ACCESS_RULES_JDBC_URL_PROPERTY);
    String username = getPersistenceProperty(ACCESS_RULES_JDBC_USERNAME_PROPERTY);
    String password = getPersistenceProperty(ACCESS_RULES_JDBC_PASSWORD_PROPERTY);
    String table = getPersistenceProperty(ACCESS_RULES_JDBC_TABLE_PROPERTY);
    String column = getPersistenceProperty(ACCESS_RULES_JDBC_COLUMN_PROPERTY);
    Connection connection = null;
    Statement statement = null;
    ResultSet resultSet = null;
    Collection&lt;String&gt; accessRules = new HashSet&lt;String&gt;();
    try {
      connection = DriverManager.getConnection(url, username, password);
      statement = connection.createStatement();
      resultSet = statement.executeQuery(&quot;SELECT &quot; + column + &quot; FROM &quot; + table);
      while (resultSet.next()) {
        accessRules.add(resultSet.getString(1));
      }
      compileRules(accessRules);
    } catch (SQLException e) {
      throw new PersistenceException(&quot;Error reading access rules&quot;, e);
    } finally {
      close(resultSet);
      close(statement);
      close(connection);
    }
  }
  
  private String getPersistenceProperty(String propertyName) {
    String propertyValue = getPersistenceProperties().get(propertyName);
    if (propertyValue == null) {
      throw new PersistenceException(&quot;Error reading acces rules, property &quot; + propertyName + &quot; must be set&quot;);
    }
    return propertyValue;
  }
  
  private void close(ResultSet resultSet) {
    if (resultSet != null) {
      try {
        resultSet.close();
      } catch (SQLException e) {
        //ignore
      }
    }
  }

  private void close(Statement statement) {
    if (statement != null) {
      try {
        statement.close();
      } catch (SQLException e) {
        //ignore
      }
    }
  }

  private void close(Connection connection) {
    if (connection != null) {
      try {
        connection.close();
      } catch (SQLException e) {
        //ignore
      }
    }
  }
}
                  
      </pre></div>
      <p>
        In your <tt>persistence.xml</tt> you can specify the needed parameters like following.
      </p>
      <div class="source"><pre>
        
&lt;persistence ...&gt;

  &lt;persistence-unit name=&quot;...&quot; ...&gt;

    ...

    &lt;properties&gt;
      &lt;property name=&quot;org.jpasecurity.security.rules.jdbc.url&quot; value=&quot;jdbc:your.db.url&quot; /&gt;
      &lt;property name=&quot;org.jpasecurity.security.rules.jdbc.username&quot; value=&quot;your_username&quot; /&gt;
      &lt;property name=&quot;org.jpasecurity.security.rules.jdbc.password&quot; value=&quot;your_password&quot; /&gt;
      &lt;property name=&quot;org.jpasecurity.security.rules.jdbc.table&quot; value=&quot;your_table_with_access_rules&quot; /&gt;
      &lt;property name=&quot;org.jpasecurity.security.rules.jdbc.column&quot; value=&quot;your_column_containing_the_access_rules&quot; /&gt;
    &lt;/properties&gt;

  &lt;/persistence-unit&gt;
&lt;/persistence&gt;       
                  
      </pre></div>
    
  </div>
</div><div class="section"><p>
	You can implement a custom security context in a similar way like the access rules provider. 
	You only have to implement the interface <i><tt>org.jpasecurity.configuration.SecurityContext</tt></i>
	and specify the property <i><tt>org.jpasecurity.security.context</tt></i>
	in your <tt>persistence.xml</tt> with the classname of your implementation of the
	interface <i><tt>org.jpasecurity.configuration.SecurityContext</tt></i>.
    Take a look at its javadoc documentation for further reference.
  </p>
  <div class="section">
    <h2>Accessing persistence properties</h2>
    <p>
      As your access rules provider your custom security context may need additional configuration parameters, too.
      You also can define them via the persistence properties in your <tt>persistence.xml</tt>. Again you have
      to implement the interface <i><tt>org.jpasecurity.persistence.PersistenceInformationReceiver</tt></i>
      to have the persistence properties injected when your security context is initialized.      
    </p>
  </div>
  <div class="section">
    <h2>Example</h2>
    
      <h2>Implementing a servlet-filter security context</h2>
      <p>
        The following code shows how to implement a security context that reads its authentication information from
        the <i><tt>HttpSession</tt></i>.
      </p>
      <div class="source"><pre>
        
public class SecurityContextFilter implements SecurityContext, Filter {

    private static final Alias PRINCIPAL_ALIAS = new Alias(&quot;principal&quot;);
    private static final Alias ROLES_ALIAS = new Alias(&quot;roles&quot;);
    private static final Alias TENANT_ALIAS = new Alias(&quot;tenant&quot;);
    private static final Collection&lt;Alias&gt; ALIASES
      = Collections.unmodifiableList(Arrays.asList(PRINCIPAL_ALIAS, ROLES_ALIAS, TENANT_ALIAS));
    
    private static ThreadLocal&lt;HttpSession&gt; session = new ThreadLocal&lt;HttpSession&gt;();

    public Collection&lt;Alias&gt; getAliases() {
        return ALIASES;
    }

    public Object getAliasValue(Alias alias) {
        HttpSession session = SecurityContextFilter.session.get();
        if (session == null) {
            return null;
        }
        return session.getAttribute(alias.getName());
    }

    public Collection&lt;?&gt; getAliasValues(Alias alias) {
        Object aliasValue = getAliasValue(alias);
        if (aliasValue instanceof Collection) {
            return (Collection&lt;?&gt;)aliasValue;
        } else if (aliasValue == null) {
            return null;
        } else if (aliasValue.getClass().isArray()) {
            return Arrays.asList((Object[])aliasValue);
        } else {
            return Collections.singleton(aliasValue);
        }
    }

    public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException {
        try {
            if (request instanceof HttpServletRequest) {
                HttpServletRequest httpRequest = (HttpServletRequest)request;
                AuthenticationFilter.session.set(httpRequest.getSession());
            }
            chain.doFilter(request, response);
        } finally {
            AuthenticationFilter.session.remove();
        }
    }

    public void init(FilterConfig config) throws ServletException {
    }

    public void destroy() {
    }
}
                  
      </pre></div>
      <p>
	    You now have to specify the class as web filter in your <tt>web.xml</tt>.
      </p>
      <div class="source"><pre>
        
&lt;?xml version=&quot;1.0&quot; encoding=&quot;ISO-8859-1&quot;?&gt;
&lt;web-app version=&quot;2.4&quot;
         xmlns=&quot;http://java.sun.com/xml/ns/j2ee&quot;
         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
		 xsi:schemaLocation=&quot;http://java.sun.com/xml/ns/j2ee http://java.sun.com/xml/ns/j2ee/web-app_2_4.xsd&quot;&gt;

    ...

    &lt;filter&gt;
        &lt;filter-name&gt;securityContextFilter&lt;/filter-name&gt;
        &lt;filter-class&gt;your.package.SecurityContextFilter&lt;/filter-class&gt;
    &lt;/filter&gt;

    &lt;filter-mapping&gt;
      &lt;filter-name&gt;securityContextFilter&lt;/filter-name&gt;
      &lt;url-pattern&gt;/*&lt;/url-pattern&gt;
    &lt;/filter-mapping&gt;
    
    ...

&lt;/web-app&gt;
                  
      </pre></div>
      <p>
        Now your login-process may store the authentication information (the principal, roles and tenant)
        in the <i><tt>HttpSession</tt></i> and you are done. 
      </p>
    
  </div>
</div><h1>5. One Step deeper</h1><div class="section"><p>
    JPA Security intercepts your action with the <i><tt>EntityManager</tt></i>.
    Whenever you retrieve an entity from your <i><tt>EntityManager</tt></i>,
    it is subsidized by a proxy from JPA Security. Likewise whenever you perform a JPQL-query,
    it is modified with additional clauses and parameters to match your security rules.
  </p>
  <div class="section">
    <h2>Modification of queries</h2>
    <p>
      JPA Security modifies the where-clause of your JPQL queries by adding restrictions
      according to your access rules. This behavior enforces security-rule-evaluation
      within the database. Only database rows resulting in entities that the user is
      allowed to read will be loaded. When using <i><tt>Hibernate</tt></i>
      as persistence provider, the <i><tt>Hibernate</tt></i>-<i><tt>WITH</tt></i>-clause
      is supported by JPA Security.
    </p>
  </div>
  <div class="section">
    <h2>Secure entities</h2>
    <p>
      The proxies that are created around your entities are called <i><tt>SecureEntity</tt></i>
      (actually they implement an interface of the same name). This is how they behave:
    </p>
    <ul>
      <li>
        
          When an entity is accessed for the first time a check is performed whether the current
          user is allowed to read the entity.
        
        
          On the first access of the entity all one-to-one- and many-to-one-relations to other entities
          are replaced by relations to <i><tt>SecureEntities</tt></i> which screen the original entities
          Furthermore one-to-many- and many-to-many-relations are replaced by <i><tt>SecureCollections</tt></i>,
          which are explained later.
        
      </li>
      <li>
        
          Changes to the <i><tt>SecureEntity</tt></i> are buffered and only flushed to the entity when the active transaction
          is committed. This occurs when <i><tt>flush()</tt></i> is called on the <i><tt>EntityManager</tt></i>
          or a query is performed with flush-mode <i><tt>AUTO</tt></i> (which is the default).
          As a matter of course whenever a <i><tt>SecureEntity</tt></i> flushes its changes a check is performed
          whether the current user is allowed to update the entity or not.  
        
        
          During the flush of a <i><tt>SecureEntity</tt></i> all relations to other <i><tt>SecureEntities</tt></i>
          or to <i><tt>SecureCollections</tt></i> are replaced by their corresponding original.
        
      </li>
    </ul>
  </div>
  <div class="section">
    <h2>Secure collections</h2>
    <p>
      Collection relationships (i.e. one-to-many- and many-to-many-relations) are handled via <i><tt>SecureCollections</tt></i>.
      Secure collections are filtered in memory and the backing collection will contain every entity of the
      original relationship. The main difference is that when you access any method of a secure collection it will behave, as if it only contained
      those entities you are allowed to read. In addition write-access will only be possible if write-access is allowed to the
      owning entity. Furthermore, for performance reasons every modification to a secure collection is queued and will not be executed until a commit operation.
    </p>  
  </div>
  <div class="section">
    <h2>Other Operations</h2>
    <p>
      Every entity that was loaded over a secured <i><tt>EntityManager</tt></i> can be casted to <i><tt>SecureEntity</tt></i>.
      This interface provides methods to programmatically check accessibility, force read- and write-check
      (via <i><tt>refresh()</tt></i> and <i><tt>flush()</tt></i>) and check the state of the entity.
    </p>
    <p>
      A secure <i><tt>EntityManager</tt></i> can be casted to <i><tt>AccessManager</tt></i>, which allows programmatic
      security-checks, too.
    </p>
    <div class="section">
      <h3>In-Memory evaluation</h3>
      <p>
        On every operation that does not result into a query to the database JPA Security tries to check the configured access rules
        in memory. That means, for normal create-, update- and delete-operations, no database interaction is needed <i>for the access check</i>.
      </p>
      <p>
        In-memory evaluation works perfectly, when no subselect is contained in the access rules. When the access rules contain
        subselects, some constraints are placed on the definition of the access rules. The first restriction is, that access rules
        that contain subselects may only contain subselects within EXISTS-clauses and not within IN-clauses. This restriction is likely to change in the future.
      </p>
      <p>
        For example the following works:
      </p>
      <div class="source"><pre>
        
GRANT ACCESS TO TestEntity entity WHERE EXISTS (SELECT e FROM TestEntity e WHERE e = entity AND ...)
                  
      </pre></div>
      <p>
        Whereas the following will not work for the current release:
      </p>
      <div class="source"><pre>
        
GRANT ACCESS TO TestEntity entity WHERE entity IN (SELECT e FROM TestEntity e WHERE ...)
                  
      </pre></div>
      <p>
        Every subselect that contains only references to pathes to properties of the checked entity will work. 
      </p>
      <p>
        For example the following works, since <i><tt>acl</tt></i> is a direct reference to a property
        of the checked entity (indicated by <i><tt>acl = entity.acl</tt></i>):
      </p>
      <div class="source"><pre>
        
GRANT ACCESS TO TestEntity entity WHERE EXISTS (SELECT acl FROM AccessControlList acl WHERE acl = entity.acl AND ...)
                  
      </pre></div>
      <p>
        Whereas the following will not work since there is no direct path from a property of the checked entity to
        <i><tt>e</tt></i> (Reverse navigation would take place from <i><tt>e.acl</tt></i> to
        <i><tt>e</tt></i>, which is currently not supported).
      </p>
      <div class="source"><pre>
        
GRANT ACCESS TO TestEntity entity WHERE EXISTS (SELECT e FROM AclEntry e WHERE e.acl = entity.acl)
                  
      </pre></div>
      <p>
        The access rule could be rewritten to work with in-memory evaluation:
      </p>
      <div class="source"><pre>
        
GRANT ACCESS TO TestEntity entity WHERE EXISTS (SELECT e FROM AccessControlList acl JOIN acl.entries e WHERE acl = entity.acl)
                  
      </pre></div>
      <p>
        When in-memory evaluation cannot take place within the previously defined constraints, there is another chance
        to evaluate a query in memory: When the entities that are needed for the specified evaluation are already loaded
        within the specific <i><tt>EntityManager</tt></i>, evaluation will take place based on that entities. That means, if
        every <i><tt>AclEntry</tt></i> of the specific entity was loaded into memory by previous operations, the following
        access rule <i>can</i> be evaluated:
      </p>
      <div class="source"><pre>
        
GRANT ACCESS TO TestEntity entity WHERE EXISTS (SELECT e FROM AclEntry e WHERE e.acl = entity.acl)
                  
      </pre></div>
      <p>
        When an access rule cannot be evaluated the access-check will return <i><tt>false</tt></i>.
        <i>This behavior will change in the future since it is not deterministic
        since the evaluation depends on previously loaded entities</i>.
      </p>
    </div>
  </div>
</div></body></html>